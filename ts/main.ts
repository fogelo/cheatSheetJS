let str = "not a number";
let number1: number = str;
let number2: number = str as any;
let obj = { str: "hello", num: 42 };
/* 
Наведя курсор на переменную можно увидеть к какому типу она принадлежит.
TS умеет выводить типы опираяью на исходные значения переменных. Если мы объявлеям переменную и присваиваем ей значение, то тип такой 
переменной будет зависеть от типа значения. И далее по коду TS будет ругаться если мы будем использовать со значеними других типов.
*/

//  @ Пример 1. Вот так можно сделать, чтобы функция работала и со строками и с массивами строк
/* function foo(x: string | string[]) {
  if (Array.isArray(x)) {
    x; // строковый тип []
  } else {
    x; // строковый тип
  }
} */


/* 
Typescript компилирует программу в другой высокоуровенвый язык программирования - javascript.
TS является надмножество JS. Любая програама на js без ошибок является программой и на ts.
*/

// @ Пример 2.

let city = 'new york city';
console.log(city.toUppercase());

/* 
Когда мы совершаем синтаксические ошибки мудуль проверки типов TS нам подскажет об этом. Он скажет, что такого свойства нет у типа string.
Эту подсказку мы получим даже на стадии написания кода и дополнительно ее же на стадии копмиляции (когда пропишем tsc).
В js такой код приведт к ошибке только на стадии выполнения. То есть движок возьмет city из лексической области видимости (из кучи по 
    определенному набору правил ), у city возьмет undefined и попытается вызвать.
*/


// зачем типы unknown, never, any, void
// Эта книга для ts 3.5.3, а что вышло позже?
let bbb = {};
