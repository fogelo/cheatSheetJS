// § Пересечение и объединение типов. https://habr.com/ru/companies/timeweb/articles/687806/
/* 

 Тип - это коллекция, множество (set) или набор значений, кооторые можно записыват в переменную

 Например number - это 0 | 1 | 2 | 3 и тд. 

 Или например:

 interface Point {
  x: number;
  y: number;
}
Point - это множество всех объектов {x: 0 | 1 | 2 и тд, y: 0 | 1 | 2 и тд}


Согласно теории множеств (set theory), Множество содержащее элементы принадлежащаие как множсеству A так и множеству B называется 
пересечением 

*/

//  @Пример 1. Пересечение (interseption) &. Это не то что есть в обоих типах, а просто объединение всех полей из двух типов в один.
/* interface Point {
  x: number;
  y: number;
}
interface Named {
  name: string;
} */
// @Пример 2. Если объединить таким образов, то получится что переменная должна содеражть одновременно значение с типом string и number
// type n = string & number; // а это пустое множество подходящих значение (never).

// @Пример 3. Если объединить таким образом, то получим объект в котором "c" будет с типом never
/* interface X {
  c: string;
  d: string;
}

interface Y {
  c: number;
  e: string;
}

type XY = X & Y;
const xy: XY = { c: "444", d: "aaa", e: "xxx" }; // "444" не подходит к типу never
 */
// @Пример 4. Пересечение (&) непримитивных значений
/* interface D {
  d: boolean;
}
interface E {
  e: number;
}
interface F {
  f: string;
}

interface A {
  x: D;
}
interface B {
  x: E;
}
interface C {
  x: F;
}

type ABC = A & B & C;

const def: ABC = { x: { d: true, e: 12, f: "fsd" } }; //то есть после x станет объектов у котоого будут все поля */

// @Пример 4. Пересечение функций

/* type F1 = (a: string, b: string) => void;
type F2 = (a: number, b: number) => void;

const f: F1 & F2 = (a, b) => {};
f(222, 111);
f("222", "111");
f("111", 111); // а для такого вызова можно объявить дополнительный тип type F2 = (a: string, b: number) => void; */

// §операторы keyof, typeof, enum. https://www.youtube.com/watch?v=cVSo2lxfw54

// @Пример 5. литеральный тип

/* 
Литеральный тип - тип переменной, котора может принмать одно конкретное значение.
*/
/* type Role = "Admin";
const currentRole: Role = "ada"; //нельзя записать ничего кроме "Admin"

// Литеральные типы можно объединять
type Roles = "Admin" | "User" | "Moderator"; */

// @Пример 6. оператор keyof
// оператор keyof используется для получения ключей любого типа
// keyof связан с литеральными типами
// keyof является объединением литеральных типов (с помощью |)

/* interface User {
  name: string;
  age: number;
}

type UserKeys = keyof User; // все равно что если бы мы здесь написали: "name" | "age", оператор keyof генерирует (возвращает) это
const prop: UserKeys = "name";

// keyof можно использовать и с классами, но keyof выводит только публичные (статичные и приватные не выводит)
class Person {
  static version = "v1";
  name: string = "";
  private age: number;
}

const personField1: keyof Person = "name";
const personField2: keyof Person = "age";
const personField3: keyof Person = "version"; */

// @Пример 7. оператор typeof и enum
// typeof нужен, чтобы записать в type тип, который ts выведет автоматически и потом его можно использовать где-то еще
/* const message = {
    id: 1,
    text: "js"
}
 */
// typeof в js (работает с const, let, var)
/* const t = typeof message 
console.log(t); // object

// typeof в ts (работает с type)
type MessageType = typeof message
const userMessage: MessageType = {} //ts теперь подскажет, какие поля должны быть

// оператор typeof и keyof вместе
type MessageKeys = keyof typeof message 
 
// использование вместе с enum, enum - это не тип, а объект, то есть он существует не только во время компеляции, но и во время выполнения
enum Colors {
    white = "#fff",
    black = "#000"
}

type ColorsType = typeof Colors
type AvailableColors = keyof typeof Colors
const c: ColorsType = {white: Colors.white, black: Colors.black} */

// § Понимание Typescript через теорию множеств https://habr.com/ru/articles/713800/

/* 
Если впустить идею, что тип это просто множество значений, все встанет на свои места

Множество - это неупорядоченная коллекция элементов.
Элементы множества пишут в фигурных скобках {A,B,C} - множество из элементов A B C, элементы могут предсавлять яблоки.
Вбольшом множестве можно выделить подмоножества отделив некоторые элементы от остальных каким-нибудь признаком.
Множество D назаывают подмножеством E если все элементы элементы D входят в E
Есть пустое множество - ∅.

1)Любое множество — подмножество самого себя.

2)Любое множество — подмножество универсально го множества.

3) Пустое множество — подмножество любого множества.

1) Объединение C = A ∪ B — все элементы, которые входят хотя бы в A или в B (свалили два пакета в один). Конечно же, A ∪ ∅ = A
2) Пересечение C = A ∩ B — все элементы из A, которые входят еще и в B. Логично, что A ∩ ∅ = ∅
3) Разность C = A | B — все элементы из A, которых нет в B. Без сомнений, A | ∅ = A


Тип - это множество javascript значений:
1) Универсальное множество - вообще все значения, которые могут появится в js программе
2) Тип(даже не ts-тип, просто тип) - какое-то множество значений. 
3) ts может описать некоторые типы, а некоторые не может. Например "все числа, кроме 0"
4) A extends B из условных типов и констрейнтов можно читать как А - подмножество B
5) ts-операторы. | и & - как раз объединение и пересечение типов как множеств
6) Exclude<A, B> по идее моделирует разность множеств, но этот джинерик работает не для всех A и B (вспоминаем пример с числом-кроме-0, Exclude<number, 0> не работает).
7) never - пустое множество

*/
// ? Как работют операции над множествами в ts
type a = false & true; // never - у множеств true и false нет общих элементов
type b = false | true; // boolean
type c = boolean & true; // true
type d = boolean | true; // boolean
type e = Exclude<boolean, true>; // false

// ? extends - нужно читать как "является подмножеством", тогда все сходится
type A = boolean extends never ? 1 : 0;
type B = true extends boolean ? 1 : 0;
type C = never extends false ? 1 : 0;
type D = never extends never ? 1 : 0;

/* 
типы null и undefined устроены, как и boolean, но в каждом из них всего по одному значению

never - это пустое множество, чтобы например показать что 2 множества не пересекаются
*/
// ? как получается never
type f = null & boolean; // never
type g = null & undefined; // never
type h = undefined & boolean; // never

// ? строки и другие примитивы
/* 
string - множество всевозможных строк
*/

// множество из 2-х строк
type Country = "ru" | "en";

// множество из всех строк начинающихся на v
type V = `v${string}`;
const v: V = "vasdf";

// ? интерфейсы и типы объектов

/*
Почему ts в этом случае не ругается? Это не баг. Просто наше представление о ts-объектах (они же интерфейсы, они же Record) 
построено на неверных предпосылках

Во первых, по аналогии с примитивными типами логично предположить, что type Sum9 = { sum: 9 } — тип для объекта-литерала, в который влезет только объект { sum: 9 }. Так вот, это работает совсем наоборот. То есть каждое поле в интерфейсе отсекает что-то от множества штук.

тип Sum9 стоит читать как, штучка, у которой по ключу sum можно достать число 9
тип {} - это не тип для пустого объекта-литерала, а штучка у которой можно получить доступ к свойствам, но в целом свойства мне не нужны. 
*/
type Sum9 = { sum: 9 };
const sum9: Sum9 = { sum: 9, a: 10 };
const x: {} = { a: 111 };
const y: {} = 9;
type AA = { sum: number } extends {} ? 1 : 0;




// ? extends


/* 
не нужно представлять цепочки наследований, их нет. Просто переводи extends как "является подмножеством"

*/



// ? мысли в кучу
/* 
Тип - это множество

В ts есть следующие множества
1) {} - множество почти всех значений, за исколючение null и undefined. Каждое свойство в интерфейсе отрезает какую-то часть от множества почти всех значений
2) unknown - универсальное множество всех значений. Но с ним не получится сделать Exclude.
3) any - какое-то множесто, но мы не знаем какое. По сути просто отключает проверку типов. 
4) never - пустое множесто
5) object - множество всех объектов со свойствами
6) bigint 
7) symbol
8) string - множество всех строк
9) number - множество всех чисел
10) boolean - множество из двух значений false и true
11) null - множество из одного значения null
12) undefined - множесво из одного значения undefened




& и | с примитивами работает логично. Возвращает тип (множество). С непримитивами же & возвращет тип, который является БЫ пересечением 
множеств. 

any и unknown ведут себя зачастую странно при использовании extends, Exclude

*/

/* 

Можно писать функции для выведения типов, тоесть они будут возвращать тип, а не значение

*/

console.log(123);
