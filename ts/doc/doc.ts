/* 
Документация на русском
https://scriptdev.ru/guide/000/#typescript_1
*/

// § Что такое TypeScript
/* 
TypeScript - это язык программирования со статической типизацией, позиционирующий себя как язык, расширяющий возможности 
JS.
Статическая типизация означает, что типы переменных не изменяются на протяжении выполнения программы. Какие задали такимми и остаются.


*/
// § Система типов, тип данных, значимые и ссылочные типы
/* 

Типизация как дорожная инфрастуктура. Типизация ограничивает возможности разработчика таким образом, что процесс создания программ
становится для него более комфортным. Тип данных определяет то, что можно делать с данными. 

Тип данных - это характеристика, определяющая множество значений и операций, которые могут быть выполнены над этими данными.


Типы данных делятся на 2 вида:
1) типы значения (value type) - хранят значение. При операции присваивания копируются в памяти
2) ссылочные типы (reference types) - хранят ссылку на значение. При операции присваивания копируется лишь ссылка на данные
*/

// § Связывание, типизация, вывод типов
/* 

?Обработка кода компилятором
Прежде чем код выского уровня превратится в последовательность машинных инструкция, которые смогут выполниться на компьютере, его 
нужно к этому подготовить. Компилятор или интерпритатор должен построить понятную ему модель на основе определяемеого языком 
синтаксиса. Пстроение модели разделяется на этапы:

1) Лексический анализ (токенизацния - tokenizingl)
    Код разбавется на лексемы var, n, =, 100, +, 2
2) Синтаксический анализ (разбор - parsing)
    Строится синтаксического дерево разбора путем определения последовательности лексем.
3) Семантический анализ
    Значения установят связь с типами данных, к которым они принадлежат. Произойдет связываение


Связывание - значение свзяыается с типом
Типизация - процесс установления принадлежности результата выражения к типу данных
Вывод типов - возможность компилятора (интерпритатора) определять тип данных, анализируя выражения
*/

// § Типизироавнные и нетипизированные языки

/* 
Языки по типизации деляться на 2 категории
1) нетипизированные или бестиповые. Assembler, Forth. Как правило очень старые и низкоуровневые языки, на которых программы являются
набором машинных команд и пишутся в основном для взаимодействия с аппаратым обеспечением (железом). Безтиповые языки позволяют производить
любые операции над любыми данными.
Отсутствие проверки типов делает низкоуровневые программы ненадежными. 
2) типизированные языки. Javd, C#, JS или Python
типизированные языки сдела разработку более осмысленной и эффективной. Поскольку каждый языка создавался для решени особых задач, все
они стали различаться по видам типизации:

 - Статичеки и динамичеки типизированные
 - сильно и слабо типизированные
 - явно и неявно типизировнные

?Контроль типов устанавливает принадлежность каждого операнда к конкретному типу данных. Любое несоответствие приводит к возникновению 
?ошибки

?Этап на котором происходит контроль типов определят вид типизации. 
Контроль типов, который происходит на этапе компиляции называется статическим контролем типов или статической типизацией.
Контроль типов, который происходит на этапе выполнения называется динамическим контролем типов или динамической типизацей.

?Статическая типизация (С#, Java): значение связывается с типом данных в момент объявления на этапе компиляции. При этом связь с типом остается неизменной. То есть, до того момента как программа будет запущена компилятор уже осуществит проверку совместимости типов, учавствущих в различных операциях. За счет того, что большая часть проверок происходит на этапе компиляции, программа обладает большей роизводительностью из-за отсутствия проверок во время выполнения. Благодаря статическому контролю типов, редактор кода способен на основе синтаксического анализа выводить вспомогательную информацию.


?Динамическая типизация (PHP, Python, Javascript): свяь значения с типом данных на этапе выполнения программы в момент присвоения. При этом связь с типом данных может быть изменена. Тиип данных может быть определен только на основании вычисленного значения. При этом операция присвоениязначения может изменить тип данных переменной, с котороым она была связана ранее.

По причине выявления несовместимости типов только во время выполнения программы ошибки выявляются менее эффективно. Программа не узнает 
о скрывающейся в ней ошибке пока не дойдет очередь до проблемного кода.

Динамическаяа и статическая - на каком этапе происходит, и неизменная связь переменной и типа данных, не меняется ,.
Сильная и слабая - разрешение выполнения выражения с разными типами. 
Явная и неявная - требование явного укзания типов.
*/

/* 
Каждый раз при присваивании значения компилятор пдовергает его проверке на совместимость с ожидаемым типом. 

Совместимость типов - совокупность правил, на основе которых программа принимает решение о возможности одного типа заменить на другой
таким образом, чтобы замена не нарушела выполнение программы.

?Виды типизации 
1) Номинативная. Тип В совмести с типом А только когда является его предком.  Присуща только статически типизировнным языкам. C#, Java
2) Структурная - совместимость типов основывается не на иерархии, а на описании типов. Типы совместимы если они имеют одинаковые
поля. Присуща только языкам с явной типизацей TypeScript, Scala
3) Утинная типизация. Ничем не отличается от структуроной типизции, но присуща только языкам с динамической типизацией.
Утинная произошла от выражения - Если это выглядит как утка, плавает как утка и крякает как утка, то это утка


*/

// § Аннотация типов - задание типа

/* 
TS - не добавляет накаких новых языковых конструкций (за исключением Enum), а лишь расширяет синтаксис за счет добавление в js типов.
От которых после транспиляцции не остается и следа, за исключением лишь того, что код js был написан с опорой как-будто эти типы были.

TypeScript является статически типизировнным языком, поэтому после того как идентификтор будет связан с типом изменить его будет нельзя.
*/

// @ Пример 1. Как укзывается тип
type Type = string;
var id1: Type = "fs";
let id2: Type = "af";
const ID3: Type = "asf";

// @ Пример 2. Как типизировать функции
type ReturnedType = string;
function f1(p1: Type, p2: Type): ReturnedType {
  return p1 + p2;
}

// @ Пример 3. Дженерик функции
// функии имеющие параметры типа являются обобщенными (дженериками(generics)). Параметры типа заключаются в угловые скобки и
// располагаются перед круглыми скобками, в которые заключены параметры функции.
function f2<U, T>(): ReturnedType {
  return "";
}

// стрелочные дженерик функции
<U, T>() => {};

// @ Пример 4. Перегрузка функций
/* 
с помощью перегрузки можно аннотировать (прописывать типы) функции с одинаковыми идентификаторами, но с различными сигнатурами
*/
type T1 = number;
type T2 = string;

function f4(p1: T1, p2: T2): T1;
function f4(p1: T1, p2: T1): T1;
function f4(p1: any, p2: any): any {
  if (typeof p2 === "string") {
    return p2;
  } else {
    return p1;
  }
}
f4(1, "12");

// § Примитивные типы
/* 
1) any
2) number
3) string
4) boolean
5) symbol
6) bigint
7) null
8) undefined 
9) void
10) never 
11) unknown 
12) enum
14) object
15) tuple

непримитивные типы (ссылочные)
1) [] или Array
2) Function
3) Object 

enum - набор логически связанных констант. В качестве значений могут выступать как числа так и строки. Это конструкция состоящая из 
именованых констант
*/

// § union (объединение) и intersection (пересечение)

class A1 {
  a: number;
  d: number;
}
class B1 {
  b: string;
}
class C1 {
  c: boolean;
}

/* 
объединение -  тип значения должен удоволетворять хотябы одному из классов
*/
let v1: A1 | B1 | C1 = { a: 1, b: "123", c: false };

/* 
пересечение - должны быть все поля из классов, мы подбираем значение для удоволетворения такого пересечения множеств
*/

let v2: A1 & B1 & C1 = { a: 1, b: "123", c: false, d: 2 };

// § type, typeof

// § tuple
// @Пример 5. типизирование параметров функции с помощью оператора rest и кортежа
function f5(...rest: [number, string, boolean]): void {}

// § interface
/* 
interface позволяет подмножесто множества object

implements - это реальизация интерфейса
*/

// @Пример 6. interface можно можно объявлять как в контексте модуля так и вконтексте функции и или метода
// в контексте модуля
interface I1 {}

// в контексте класса
class C2 {
  public method(): void {
    interface C2 {}
  }
}
// в контексте функции
function f6(): void {
  interface F6 {}
}

// @ Пример 7. реализация интерфейса (implements)
/* 
Класс реализующий интерфейс должен реализовывать его в полной мере. 
Все поля интерфейса являются public и их поля не могут содержать static

Несмотря на то, что в интерферйсе можно декларировать поля и методы, в нем нельзя декларировать свойства get и set (аксессоры (геттеры и сеттеры))). Но поле заделарированное в интерфейсе в классе может быть аксессором.


*/

interface IAnimal {
  id: string;
  nickname: string;
  execute(command: string): void;
}
interface IOviparous {} // указывает на возможность откладывать яйца

class Dog implements IAnimal {
  nickname: string;
  get id() {
    return "123";
  }
  execute(command: string): void {}
}

// один класс может реализовывать сколько угодно интерфейсовъ
interface IAnimal {}

class Bird implements IAnimal, IOviparous {
  nickname: string;
  get id() {
    return "123";
  }
  execute(command: string): void {}
}

//класс Eagle расширяет класс Bird, который реализует интерфейс IAnimal
class Eagle extends Bird implements IAnimal {}

// Интерфейсы могут расширятся
interface IIdentifiable {}
interface ILiving {}
interface IAnimal extends IIdentifiable, ILiving {}

// Интерфейс может расширить класс
class Car {
  nickname: string;
  age: number;
}

interface IAudi extends Car {}

// слияние интерфейсов
interface User {
  name: string;
}

interface User {
  age: number;
}
/*
как видит компилятор
interface User {
    name: string;
    age: number;
}
*/

// § Объектные типы с индексными членами. Или определение динамические
// @ Пример 8. пример как можно использовать динамическое определение типов

interface A2 {
  [key: string]: string;
  [key: number]: string;
}
let a: A2 = {
  validKeyDeclareStatic: "value", // Ok, значение принадлежит к string
  invalidKeyDeclareStatic: 0, // Error, значение должно быть совместимым с типом string
};

a.validKeyDefineDynamicKey = "value"; // Ok
a.invalidKeyDefineDynamicKey = 0; // Error, значение должно быть совместимым с типом string
a[0] = "value";

// § Модификаторы доступа (Access Modifiers)

/* 
Модификаторы доступа - это ключевые слова, с пмощью которых осуществляется управление сокрытием данных в классе. 
После компиляции typescript от них не остается и следа

В typescript существует 3 модификтора доступа.
1) public - если не объявлен другой, то этот модификтор используется по умолчанию
public свойства доступны в определящих их классах, классах потомках и экземплярах классов
2) protected - свойства доступны только внутри определяющего класса и его потомков (в экземпляре нет)
3) private - свойства доступны только внутри класса в котором определены.
*/

//@ Пример 9. Для классов существует сокращенная запись для объявления полей
// такую запись
class BirdEntity {
    public name: string;
    public age: number;
    public isAlive: boolean;
  
    constructor(name: string, age: number, isAlive: boolean) {
      this.name = name;
      this.age = age;
      this.isAlive = isAlive;
    }
  }

// Можно сократить до такой
class FishEntity {
    constructor(
      public name: string,
      protected age: number,
      private isAlive: boolean
    ) {}
  }
// В js есть нативный способ задания private полей
  class Developer {
    #isLife: boolean = true; // защищенное поле класса
  
    get isLife() {
      return this.#isLife;
    }
  }

  // § Модификатор readonly
  /* 
  readonly - модификатор, который запрещает изменение полей объекта. Аналог const для свойств объекта
  */

//@ Пример 10. исользование readonly
interface IAnimal {
    readonly name: string;
  }
  
  class Animal {
    public readonly name: string = 'name';
  }