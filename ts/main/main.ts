/* 
Если даже мы просто подключили в проект ts и используем расширение ts, то мы пише на typescript. Даже если мы явно не указвает типы, они 
все равно выводятся и согласовываются по умолчанию.
*/
/* let str = "not a number";
let number1: number = str;
let number2: number = str as any;
let obj = { str: "hello", num: 42 }; */
/* 
Наведя курсор на переменную можно увидеть к какому типу она принадлежит.
TS умеет выводить типы опираяью на исходные значения переменных. Если мы объявлеям переменную и присваиваем ей значение, то тип такой 
переменной будет зависеть от типа значения. И далее по коду TS будет ругаться если мы будем использовать со значеними других типов.
*/

//  @ Пример 1. Вот так можно сделать, чтобы функция работала и со строками и с массивами строк
/* function foo(x: string | string[]) {
  if (Array.isArray(x)) {
    x; // строковый тип []
  } else {
    x; // строковый тип
  }
} */

/* 
Typescript компилирует программу в другой высокоуровенвый язык программирования - javascript.
TS является надмножество JS. Любая програама на js без ошибок является программой и на ts.
*/

// @ Пример 2.

// let city = "new york city";
// console.log(city.toUppercase());

/* 
Когда мы совершаем синтаксические ошибки мудуль проверки типов TS нам подскажет об этом. Он скажет, что такого свойства нет у типа string.
Эту подсказку мы получим даже на стадии написания кода и дополнительно ее же на стадии копмиляции (когда пропишем tsc).
В js такой код приведт к ошибке только на стадии выполнения. То есть движок возьмет city из лексической области видимости (из кучи по 
    определенному набору правил ), у city возьмет undefined и попытается вызвать.


? Вывод типов на основе значений является основным занятем TS

Исключения - это значит предусмотреть действия пользователя (или программ), которые могут привести к ошибке. 
TS подсказывает такие потенциальные места, что позволяет позаботиться о них до непосредственнго выполнения js в браузере. То есть основная задача
ts это поиск кода, которй может выдасть такое исключение при выполнении и сообщить об этом разработчику.

Исключения - это код, который предусматривает ошибки. TS помогает такие места отловить и написать такой код.

*/

/* 
функции в js всегда что-то возращают, если не указать явно return, то вернет undefined

void - пустота
void -  в js это оператор, который всегда возвращает undefined, например void 2 вернет undefined
void - в ts это тип данных сообщающий, что функция ничего не возращает, то есть возвращает undefined


Одна из целей системы типов TS - это поиск когда, который выдаст исключение при выполнении, без запуска кода.

аннотироание типов - явное прописывание типов, когда вы сообщаете ts о ваших намерениях, что повзолит ему лучше обнаруживать исключения.

система типов ts моделирует процесс выполнения js
*/

/* 

Система типов TypeScript не гарантирует точности своих статичных типов. Если таковая точность для вас важна, обратите внимание на другие языки вроде Reason или Elm
*/

// @ Пример 3. Если навести на функции, ts выведет тпиы, которые он вывел

function add(a, b) {
  return a + b;
}

// зачем типы unknown, never, any, void
// Эта книга для ts 3.5.3, а что вышло позже?

/* 
tsc - компилятор

Что делает tsc? 
1) Конвертирует новый ts или js в старый js (поддерживаемый в браузерах). Транспиляция
2) Проверяет код на наличие ошибок типов

let x = 'hello'; x = 1234;
-Type '1234' is not assignable to type 'string'. 
Это можно перевести так тип значения 1234 не подходит для типа, который может быть в этой переменной, в данном случае string

*/

// @ Пример 4. instanceof не работает с типами TS
/* interface Square {
  width: number;
}
interface Rectangle extends Square {
  height: number;
}
type Shape = Square | Rectangle;

// вот так не проверить на наличик свойства в объекте 
function calculateArea1(shape: Shape) {
  if (shape instanceof Rectangle) {
    return shape.width * shape.height;
  } else {
    return shape.width * shape.width;
  }
}

// поэтому делаем вот так например
function calculateArea(shape: Shape) {
  if ('height' in shape) {
    shape; // Тип Rectangle
    return shape.width * shape.height;
  } else {
    shape; // Тип Square
    return shape.width * shape.width;
  }
}


// или можем вообще использовать классы, так как классы могут быть и типами и значение. Они не стираются при компиляции в отличи от типов ts
class Square {
  constructor(public width: number) {}
}
class Rectangle extends Square {
  constructor(public width: number, public height: number) {
    super(width);
  }
}
type Shape = Square | Rectangle;
function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    shape; // Тип Rectangle
    return shape.width * shape.height;
  } else {
    shape; // тип Square
    return shape.width * shape.width; // ok
  }
}
 */

/* 
Проверка instanceof происходит при выполнеии кода, а тип Rectangle на код не влияет. Так как типы TS являются "стираемыми", то
при компиляции кода в js из него удалются все interfaces, types и аннтотации типов.
*/

// @ Пример 5. as number. Не влияет на выполнение. То есть она не делает преобразование

// Нормализация строки либо числа исключитель в число
//as number не говорит верни нам число, он указывает что воспринимай значение которое мы возращаем как число, а это может привести к ошибкам
/* function asNumber1(val: number | string): number {
  return val as number;
}

//Поэтому делаем так 
function asNumber2(val: number | string): number {
  return typeof val === "string" ? Number(val) : val
}
 */

// § Правило 4. Привыкайте к структурной типизации
/* 

Развитие навыка структурной типизации позволит лучше чувствовать код, где дейсвительно есть ошибки и писать более надежный код
*/

// Вот так модуль проверки типов ругаться не будет, то есть у нас полей больше а не меньше
/* interface Vector2D {
  x: number;
  y: number;
}
function calculateLength(v: Vector2D) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}
interface NamedVector {
  name: string;
  x: number;
  y: number;
}

const v: NamedVector = { x: 3, y: 4, name: "Zee" };
calculateLength(v); // ok, результат равен 5.
 */
/* 
Мы даже не объявляи связи между Vector2D и NamedVector, а ts не ругается. Структура Vector2D и NamedVector сопоставима, поэтому ts не ругается, так как он моделирует поведение js. Отсюда выражение "структурная типизация"
*/

// § Правило 5. Ограничьте применеие типов any

/* let age: number;
age = "12";
// ~~~ Тип '"12"' не может быть назначен для типа 'number'.
age = "12" as any; // ok
age = 15;
age = {} as number;
 */
/* 
с момощью as any мы как-бы говорим ts, чтобы он воспринимал значение с типом, который укажем сами. Таким образом обманываем ts как-бы
*/

//@ Пример 6. Если значению присвоен тип, то языковые службы typescript способны предоставить соответствующие автоподстановки и документацию
// вот так автоподстановка будет работать6, так типы все равно были автоматически выведены
/* let obj1 = { str: "hello", num: 42 };
obj.num;
// а вот так не будте
let obj2: any = { str: "hello", num: 42 };
obj2.str; */

//@ Пример 7. Если мы выделим first и нажмем f2 (правой кнопкой Rename Symbol), то у нас изменится только интерфейс и соответствующие
// @ ему объекту. Any не изменятся. Если также выделить first где тип не указан или any переименовать вообще не выйдет.

/* interface Person {
  first: string;
  last: string;
}
const formatName = (p: Person) => `${p.first} ${p.last}`;
const formatNameAny = (p: any) => `${p.first} ${p.last}`;
const formatNameAny2 = (p) => `${p.first} ${p.last}`; */

/* 
Слоган typescript - это javascript, который масштабирутеся. Ключевой состовляющей масштабирования выступают языковые службы. 
Утрата возможности их применения ведет к падению производительности
*/
// в js вот так проверят типы нормально
if (typeof p === "object") {
}

//@ Пример 8. declare
/* 
Можно писать декларацию окружения для сторонних библиотек js. Хорошая практика.
declare - ключевое слово, чтобы сообщить, что мы пытаемся описать код, которые уже существует.

например в файле lib.dom.d.ts, который качается вместе с ts прописаны декларации, которые описывают функуиональность, которую предоставляет 
браузер 
lib.dom.d.ts - библиотека деклораций типов, которую typescript содержит для DOM

Освойте работу с файлами деклораций, чтобы видеть каким образом моделируется поведение кода

*/

// Вот так в файле lib.dom.d.ts описана функция fetch, можно через f12 (правой кнопкой go to defenitions провалиться к типу) и
/* declare function fetch
  (input: RequestInfo, init?: RequestInit
): Promise<Response>;
const aaa = fetch("asdf") */

// § Правило 7. Воспринимайте типы как наборы значений

/* 
наборы значений - называют область типов, это типы значений которые можно записать в переменную
В зависимости же от настройки опции strictNullChecks, null и undefined могут являться или не являться частью области.
например можно воспринимать тип number как набор числовых значений (32,123 ,4,)


1) never - пустой набор, это значит что в переменную нельзя присвоить никакое значение.
2) type A = 'A' - набор с единичным значением. Это качается литералных типов.
3) type AB12 = 'A' | 'B' | 12 - формирование типов принимающих несколько значений, объединение типов 


number можно воспринимать как type Int = 1 | 2 | 3 | 4 | 5 // | ...

assignable (может быть назначен)
 */

// @ Пример 9. PersonSpan - это набор из Person и Lifespan;
/* interface Person {
  name: string;
}
interface Lifespan {
  birth: Date;
  death?: Date;
}

// PersonSpan и PersonSpan3 идентичные типы.
type PersonSpan = Person & Lifespan;
interface PersonSpan3 extends Person {
  birth: Date;
  death?: Date;
}

type PersonSpan2 = Person | Lifespan;

const ps: PersonSpan = {
  name: "Alan Turing",
  // birth: new Date('1912/06/23'),
  death: new Date("1954/06/07"),
  // xxx: "adfasdf"
}; // ok

const p2: PersonSpan2 = { name: "adf", death: new Date("1912/06/23") }; // ok */

/* 

оператор & говорит, что нужно взять все поля из типов

Type '{ name: string; birth: Date; death: Date; xxx: string; }' is not assignable to type 'PersonSpan'. - эта ошибка значит, что тип который 
вывел модуль проверки типов ts из значения не подходит к тому, кторый мы указали для него явно.


? Рассуждение о типах как о наборах значение помогает легче ими оперировать
*/

// @ Пример 10. keyof что будет и почему?
// Не существует ключей, гарантированно принадлежащих значению типа объединения, поэтому keyof для этого объединения будет пустым набо- ром (never)
type K = keyof (Person | Lifespan); // never видимо так как не понятно что может содержать, а что нет
type L = keyof (Person & Lifespan);
type M = keyof Person | keyof Lifespan;

/* 
keyof (A&B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
Если вы понимаете, почему выполняются эти уравнения, значит, вы далеко продвинулись в понимании системы типов TypeScript.

*/

// @ Пример 11. массивы и кортежи.

const list1 = [1, 2]; // Тип number[] 
const tuple1: [number, number] = list1;
/* 
тип number[] не может быть назначени для [number, number] поскольку не является его подмножеством, а нвооборот сожео
*/

const list2: [number, number]  = [1, 2]; // Тип number[] 
const tuple2: [number, number, number] = list2;
/* 
Нет, и по весьма интересной причине. Вместо того чтобы моделировать пару чисел как {0: number, 1: number}, TypeScript моделирует ее как {0: number, 1: number, length: 2}. Это полезно — вы можете проверить длину кортежа, и она исключит лишнее назначение.
*/


// @ Пример 12. Что будет и почему?

type T = Exclude<string|Date, string|number>; // Тип Date
type NonZeroNums = Exclude<number, 0>; // Тип все еще просто number