/* 
требуется понимание того как именно работает движок js. Отюда вытечет понимание остального.
Как работает js движок


-движок js это один из нескольких компонентов браузера наряду с движком рендеринга и сетевым уровнем (они между собой взаимодействуют)

javascript - является одновременно компилируемым и интерпретируемым языком
V8 (один из движков js) - программа, интерпретатор который читает(парсит) js код. Не браузер читает, а движок который в нем. V8 написан google на C++
V8 используется на Node.js

-V8 синхронно по порядку строчку за строчкой читает js код. 
-Скомпилированный код выполняется быстрее(так как не тратит время на преобразваоние в машинный код)


javascript - является однопоточным


-когда происиходит вызов функции создается контекст выполнения и только потом выполняется код внутри функции

//Что делает движок js?
1. создает глобальный контекст выполенения(global execution context). Внутри него выполняется весь js код
    голобальный контекс создает: 1) объект window и 2) переменную this

//Как именно создается контекс выполнения функции
1. этап создания - настривает так что код может быть выполнен. 
На этом этапе определяется scope(область видимости(действия)) и определяется значение this
2. этап выполнения - 

-цепочкой областей действия (scope chain)

-контекст выпоолнения - это scope +this (контекст - это объект на который ведет this )
-конекст выполнения функции - он определяет какие переменные доступны в этой конкретной функции, какое значение this внутри нее, какие переменные и функции объявлены внутри нее

//стек выполнения(вызова) или call stack - 
-js - однопоточный язык программирования. Это значит, что у него только один call stack. А это значить что он в один момент времени он может выполнять
только одну задачу
-стек выполнения - это структура данных, которая, говоря упрощенно, записывает сведения о месте в программе, где мы находимся
                    структура данных, которая функционирует по принципу LIFO


- когда код внутри функции выполнен ее контекст уничтожается. Если функция вызвается внутри другой функции, то для нее тоже формируется отдельный 
контекст. Таким образом существует уже 2 контекста. Контекстов выполнения функций может быть много, но работает один. Чтобы отслеживать какой из них 
выполняется в данный момент используется стек, где текущий контекст находится на вершине стека. Как только он завершит выполнение. Он будет извелечен из 
стека и пойдет выполнятся следущий. И так пока дело не дойдет до глобального контекста



web api браузера - это
*/



////!конексты выполнения функции зависит от того где она была ообъявлена, а не от того где она выполняется
/* 
Контекст выполнения функции создается в 2 этапа: 
1) определяется область действия(scope)(зависит от того где была объявлена функция) 
2) определяется this (зависит от того как объявлена(просто объявление или стрелка) и как вызывается функция). 
    В случае стрелочных функций this будет искаться как обычная переменная, в своей области видимости не найдет и будет подниматься по цепочке выше.
    То есть важно где стрелка объявлена, а не где и как вызывается

? в чем разница между functin arrow и function declrataion? (подсказка this)
    в стрелках this определяется в зависимости от того где она объявлена
    в обычках this определяется в зависимости от того где и как она вызываеется
/* 


//Что выведет и почему?
function a() {
    function b() {
      console.log(foo); // logs 'bar'
    }
    var foo = 'bar';
    b();
  }
  a();
 */


/*   
//Что выведет и почему?
function a() {
    var foo = 'bar';
    b();
  }
  function b() {
    console.log(foo); // throws ReferenceError: foo is not defined
  }
  a(); 
  */



/*   
//Что выведет и почему? 
//что особенно в замыканиях дак это то, что даже после того как код внешней функции будет выполнен, контекст ее выполнения извлечен из стека и уничтожен, внутрення функция все равно будет иметь ссылку на область действия внешней функции. 
function a() {
    var name = 'John Doe';
    
    function b() {
      return name;
    }
    return b;
  }
//Переменная c является просто сслыкой на внутренню функцию b. Поэтому вызов с() фактически вызывает внутреенюю функцию а().
  var c = a();
  c(); 


  */


/*   
?1. В чем отличие фреймворка от библиотеки?
    Вызов метода из библиотеки происходит по требованию разработчика. При использовании фреймворка - наоборот, фреймворк производит вызов кода разработчика. 
*/



/* defer и async при подключеии скрипта */



// § статья как работает js
