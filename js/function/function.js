/* 

-интерпретатоор
-область видимости (scope)
-лексическая область видимости      - механизм и определение в целом. то есть как это работает (родители и потомки). как движок ищет переменные в областях
-функциональная область видимости   - область видимости внутри функции
-блочная область видимости          - область видимости внути блоки
-локальная область видимости        - их много. Переменные в ЛОВ не видны в ГОВ (все что доступно родителю доступно ребенку, но не наоборот)
-глобальная область видимости       - только одна
-пространство имен
-перменные var, let, const
-function decloration, function expression, arrow function
-this
-контекст выполнения                это scope+this
-стек вызовов
-функция                            - 
-лексическое окружение              - все доступные переменные с их значениями и функции для взаимодействия (то что окружает нашу ф-ю или переменную)
-замыкание                          - комбинация функции и ее лексического окружения (в js нет функций, а есть замыкания)



область видимости в js - это текущий конекст в коде

this - это ссылка на объект, метод которого мы вызываем. Важно понимать в рамках какого объекта вызывается функция. 

Когда вызывается функция у нее есть доступ к объекту в рамках которого она вызывается. Можно к нему обращаться, а можно и не обращаться
?как тогда если это ссылка она в конструкторе

*/

//Контекст выполнения функции (this). Стрелочные и обычные функции.

// поведение(потеря) this при передаче колбека

//Стрелочные функции - это сокращенный способ записи анонимных функций (они не замена традиционным функциям)

//Стрелочные функции хорошо раскрываются в колбеках

//Когда вызываем обычную функцию у нас есть доступ к объекту

//контекст можно подменять  методы call, apply, bind

/* 
?1. что значит у стрелочных функций нет собственного this?
?2. что такое this? что такое scope? что такое лексическое окружение? что такое замыкание? что такое область видимости? что такое контекст выполнения(вызова)?
?3. что такое область видимости функции? К каким переменным имеет доступ функция?
?4. как ведет себя this в строгом и не строгом режимах?
?5. что будет если мы в объекте обратимся к свойству не через this, а захардкоржим объект в котором находится метод
*/

/* 
-замыкание - комбинация функции и лексического окружения в котором эта функция была определена.
-замыкание - это функция у которой есть доступ к своей внешней функции, даже после того как внешняя функция отработала.
объекты хранятся по ссылке, а функция это объект
-вложенные функции имеют доступ к переменным, объявленным вовне.

замыкание - это функция 
замыкание создается каждый раз когда создается функция. 
замыкание - это функция имеет доступ к переменным и их значениям своей внешней функции, даже после того как она отработала. 
*/

//§HOISTING (ПОДНЯТИЕ)

/* 
//поднятие переменных 
-hoisting - объявления переменных(var) и функций попадают в память в процессе фазы компиляции, то есть до выполнения. Поэтому есть возможность вызывать в коде функции до их объявления
-hoisting - механизм поднятия переменных и функций наверх их области видимости перед выполнением кода
-поведение var отличается от let и const. Var имеет функциональную область видимости и соответственно будет подниматься до открывающей фигурной скобки
блока функции (остальные блоки игнорирует и поднимается несмотря на них). Let и const имеют блочную область видимости и соответственно будут подниматься до фигурных скобок любого блока (в том числе и блоков циклов)
- js неуклонно сначала объявляет переменную, а уже потом ее инициализирует (var foo = 1) 
*/

//поднятие функций

/* 
//function decroation - поднимается перед выполнением
hoisted(); // Вывод: "This function has been hoisted."

function hoisted() {
  console.log('This function has been hoisted.');
};
 */

/* 
//function expression - не поднимаются перед выполнением
expression(); //Вывод: "TypeError: expression is not a function

var expression = function() {
  console.log('Will this work?');}
*/

//§ПРИМЕРЫ ДЛЯ ТОГО ЧТОБЫ ПОНЯТЬ ЧТО ТАКОЕ ЗАМЫКАНИЕ И КАК РАБОТАЕТ EVENT LOOP

//// что выведет и почему?
//1. понял на этом примере, что цикл выполняется просто когда условие внутри него возвращает true (тип данных внутри скобок преобразуетс в булевый)
//2. вернет девять нулей так как каждый цикл будет добавлять в стек анонимную функцию, но начнут они выполнятся только после того как все добавятся.
//   Соответственно когда они начнут выполнятся i для всех будет одинакова.
//3. Понял, что в стек попадают не только функции, а замыкания (комбинация функция+лексическое окружение)
//4. понял как работает event loop. Все синхронные функции попадают в call stack и сразу вызываются. setTimout же попадает в call stack и вызывается,
//   анонимная функция внутри него попадет(регистрируется) в web api браузера там готовится(ждет) и как будет готова попадает в очередь (callback queue)
//   и только затем она попадает в стек (call stack)

/* 
let i = 10;
while (--i) {
    setTimeout(() => {
        console.log(i)
    }, 0)
} */

////Что выведет и почему?
//1. понял что такое стек (последний пришел первый ушел) и очередь (последний пришел последний ушел)
//2. вернет по порядку числа от 9 до 1. Так как каждое замыкание попадет в очередь(event loop) со своим значением k
/* let j = 10
while (--j) {
    let k = j;
    setTimeout(() => {
        console.log(k)
    },)
}
 */

////Что выведет и почему?
/* let j=10
while (--j) {
    console.log(j)
}  */

/*
////что выведет и почему?
//переменная var i объявится, инициализируется внутри блока,  но перед выполнением поднимется за пределы блока, в результате когда будут отрабытвать
//функции они возьмут i из внешней области
for (var i = 0; i < 10; i++) {
    setTimeout(() => console.log(i), 0);
}
//переменная let i объявится, инициализируется внутри блока и перед выполнением поднимется до верха блока. Значит каждый раз когда будет выполнятся цикл замыкание будет попадать в очередь
//со своим значением i
for (let i = 0; i < 10; i++) {
    setTimeout(() => console.log(i), 0);
}
//если не задать let переменная объявится как var
for (i = 0; i < 10; i++) {
    setTimeout(() => console.log(i), 0);
}
 */

/* 
////Что выведет и почему?
//выведутся числа от 0 до 9. видимо из за того что в setTimeout мы передаем просто инструкцию а не функцию и она сразу регистрируется 
//в web api со значением, например вот так console.log(2)
for (var i = 0; i < 10; i++) {
    setTimeout(console.log(i), 0);
}
for (let i = 0; i < 10; i++) {
    setTimeout(console.log(i), 0);
} */

/* 
//что выведет и почему?
//выведутся числа от 0 до 4 так как здесь используется IIFE (Immediately Invoked Function Expression) - немедленно исполняемые функциональные выражения.
//испльзовали часто до появления let и const, чтобы ограничить область видимости для var
for (var i = 0; i < 5; i++) {
    (function logIndex(index) {
      setTimeout(function () {
        console.log('index: ' + index);
      }, 1000);
    })(i)
  } */

/* let i = 10;
while (--i) {
    setTimeout(() => {
        console.log(i)
    }, 0)
} */

/* 
////Что выведет и почему?
//1. создаем массив из замыканий
let functionArr = []
let j = 10
while (--j) {
    var k = j;
    functionArr.push(() => {
        console.log(k)
    })
}
functionArr[2]() 
*/

/* 
//что выведет в консоли и почему
//1. Показываем как внутренней функции остается доступ к переменным внешней даже после того как внешняя отработала (замыкание)
function getCounter() {
    let counter = 0
    return function () {
        return counter++
    }
}

let count = getCounter()
console.log(count())
console.log(count()) 
*/

//что такое лексическое окружение и области видимости

/* 
//интерпретатор js 
-при исполнеии js кода интерпретатор проходится по нему дважды.
1-й проход (проход компиляции) - интерператор просматривает код в поисках объявлений переменных и функций и поднимает их наверх 
их текущей области вдимости. (поднимаются только объявления переменных, присвоения остаются на своих местах. Функции поднимаются целиком)
2-й проход (проход исполнения) - интерпретатор присваивает значения переменным и исполняет функции

-когда интерпретатору нужно найти объявление переменной он сначала ищет ее в текущей области видимости, если не находит выходит в родительскую 
область видимости и ищет там и так продолжается до глобальной области видимости. 

-к переменным обьявленным в дочерней области видимости из родительской получить доступ нельзя

-лексическая область видимости
-функциональная область видимости
-блочная область видимости


JS идёт от самой глубоко вложенной ОВ наружу, пока не найдёт искомую функцию, объект или переменную.

замыкания живут в тесном союзе 

-в js все функции являются замыканиями (лексичекими). Это значить функция представляет собой не только фрагмент выполняемого когда, но и 
контекст в котором этот фрагмент будет выполняться. В js контекст представляет собой подобие некой цепочки первым звеном которого является объект,
который включает в себя все локальные переменные и сслыку на объект в контексте которого функция была объявлена

-функции в js являются замыканимя, это значит что они хранят контекст в котором были объявлены



 */

/* 
//стек выполнения(стек вызова) контекст выполнения функции
-каждый раз когда вызывается функция для нее создается новый контекст
-js движок - это прорамма которая обрабатывает js код (интерпретатор). Один из них и есть V8
-идентификтор - это имя переменной
*/

/* 
-this в стрелочной функции будет равен this ее внешней функции (у нее своего нет и он будет искаться в области видимости по цепочке)
*/

/* console.log('================================ Замыкание ================================')
//§ЗАМЫКАНИЕ https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures

//Функция замкнута в своем лексическом окружении
function makeClosure() {
    let myName = 'Anton'
    return function showName() {
        console.log(myName)
    }
}

let getMyName = makeClosure()
console.log(getMyName())
 */

/* 
//§ Метод bind()
let user = {
    firstName: "Вася",
    sayHi() {
        console.log(`Привет, ${this.firstName}!`);

    }
}
// вот так контекст потеряется
setTimeout(user.sayHi, 1000); // Привет, undefined!

// а так не потеряется (метод bind)
setTimeout(user.sayHi.bind(user), 1000); // Привет, Вася!

 // и так не потеряется (анонимная стрелочная функция)
setTimeout(()=>user.sayHi(), 1000); // Привет, Вася!

 */

// @ Пример 1. Оператор rest

/* 
мы можем с помощью ...rest показать, что у нас функция принимает неограниченное количество параметров, которые потом мы можем достать 
из массива rest в теле функции обращаяясь к параметрам по индексу. 

*/
function aaa(...rest) {
  console.log(rest[0]);
  console.log(rest[1]);
}
aaa(1, 2);
