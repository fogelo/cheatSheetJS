/* 
  Программа - это набор инструкций, сообщающих компьютеру что нужно сделать. 
  {} или 2 - это литеральные значения, поскольку они сами по себе,тоесть не хранятся в переменной.
   Значения, непосредственно включаемые в исходный код, называются литералы
    
   
   ? Чтобы ввести несколько строк в консоли за раз, используйте <shift> + <enter>, чтобы переместиться на новую строку.

   ? Вы должны стремиться писать программы, которые не только правильно работают, но и понятны при их изучении. 

   ? В js типизированные значения, а не типизированные переменные. 
   ? Только у значений есть типы в JavaScript, переменные являются всего лишь контейнерами для этих значений

   Переменная - контейнер, чтобы хранить определенный тип значения. 
   Статическая типизация - контроль типов.
   Динамическая типизация - слабая типизация, позволяет переменной хранить значение любого типа в любой момент времени.

*/

/* //@Взаимодействие c пользователем через propmt
age = prompt( "Please tell me your age:" );
console.log( age ) */

//  break и return

// анонимные и именованные функции
var foo = function () {
  // ..
};
var x = function bar() {
  // ..
};

// Выражения немедленно вызываемых функций (Immediately Invoked Function Expressions (IIFEs))
// Нужно чтобы объявлять переменные, которые не будут влиять на код, окружающий IIFE снаружи
(function IIFE() {
  console.log("Hello!");
})();
// "Hello!"


// §Замыкание
// Замыкание - возможность запомнить и продолжить работу в области видимости функции даже когда функци уже закончила свою работу
//@ Пример замыкания 1
// В данном примере makeAdder заканчивает свою работу, но мы имеем достуа к ее переменной x. Когда мы вызываем makeAdder(1) она нам
// возвращает ссылку на ее внутреннюю функцию add, которая запоминает x как 1. Мы эту ссылку называли plusOne
const makeAdder = (x) => {
  const add = (y) => {
    return x + y
  }
  return add
}
const plusOne = makeAdder(1)
console.log(plusOne(10))
console.log(plusOne(20))


//@ Пример замыкания 2
// В данном примере после того как функция foo1 отработала функция add все еще имеет доступ к переменной x
const foo1 = () => {
  let x = 0
  const add = (y) => {
    x = x + y
    return x
  }
  return add
}
const bar1 = foo1()
console.log(bar1(5))
console.log(bar1(5))