//§ Область видимости (scope) и замыкания (closures)

/* 
@ Что такое область видимости? 
Одна из самых фундаментальных парадигм, практически всех языков программирования - это возможность хранения значений в переменных и возможность 
последующего их чтения и изменения. Возможность сохранения и чтения значений из переменных - то, что образует состояние программы. 
Включение переменных в программу поднимает самый интересный вопрос. Где размещаются эти переменные? Как наша программа находит их когда в 
них возникает надобность? 
? Область видимости (scope) - это набор правил для хранения переменных в определенном месте и их нахождения в будущем.
Но где и как задаются эти правила?

?Немного о компиляторах 
Перед выполнением исходный код (ваша программа) проходит через 3 основные фазы обработки, которые приближенно объединяются термином компиляция:
    1) Лексический анализ/Разбиение на токены (Lexing/Tokenizing) - разбиение последовательности симоволов исходного кода на осмысленные (с точки зрения языка фрагменты),
называемые токенами. Например var a = 2 разобъется на var, a, = и 2
    2) Разбор (Parsing) - преобразование потока (массива) токенов в дерево вложенных элементов (Abstract Syntax Tree)
    3) Генерация - преобразование AST в исполняемый код.


Для простоты будем считать, что любой фрагмент js кода должен компилироваться перед его выполненим. Компилятор берет программу var a = 2 сначала компилирует
ее, а потом сразу готовит ее к исполнению.

Участники обрабатывающие программу var a = 2:
    1) Движок - отвечает за всю компиляцию и выполнение.
    2) Компилятор - друг движка, который берет на себя черновую работу по разбору и генерированию кода
    3) Область видимости - друг, который собирает и ведет список всех объевленных идентификаторов (переменных) и устанавливает 
    строгий набор правил их доступности для кода, выполняемого в данный момент


var a = 2 - Движок здесь видит 2 команды, одну Компилятор выполняет во время компиляции, вторую Движок выполняет во время выполнения.

 ?Этапы процесс обратоботки программы var a = 2 Движком и другими компонентами: 
    1. Прежде всего компилятор проводит лексический анализ и разбирает программу на токены, которые потом затем разбираются в дерево (AST). 
    2. Генерирует код. 
       Не совсем точное описание кода c помощью псевдокода, который в итоге генерирует Компилятор: 
        "Выделить память для переменной, присвоить ей метку a, сохранить в этой переменной значение 2".

       Более точное описание:
            1) Обнаруживая var a, К обращает к ОВ, чтобы узнать существует ли переменная a в наборе этой конкретной ОВ. Если да, то К игнорирует объявлениеи 
            и двигается дальше иначе обращается к этой ОВ и просит завести(объявить) перменную а
            2) Компилятор генерирует код для последующего его выполнения Движком для обработки присваиваня a = 2. Код, выполняемый движком сначала спрашивает
            у ОВ доступна ли переменная a в наборе текущее ОВ. Если переменная доступна, то движок использует эту переменную если нет, то двигается дальше.
            Если движок в конечном итоге находит переменную он присваивает ей значение 2. Если нет движок поднимает тревогу и сообщает об ошибке. 

Подведм итог:
Для присваивания значения переменной выполняются 2 разных действия. Сначала компилятор объявляет переменную (если она не была объявлена) в текущей ОВ,
а затем при выполнении Движок ищет переменную в ОВ, и если переменная будет найдена присваивает ей значение, 
если не удается найти Движок обращает к следующей ОВ. Да, областей видимости несколько

Компилятор - объявляет. То есть объявление на стадии компиляции
Движок - присваивает. А присваивание на стадии выполнения


Типы поиска переменных Движком в ОВ. LHS-ссылки и RHS-ссылка
1) LHS (lefthand side) - левосторонний, пытается найти переменную-контейнер для присваивания
2) RHS (righthand side) - правосторонний, пытается найти переменную, чтобы получить значение


? Какие бывают ошибки?
1) ReferenceError - относится к проблемам при разрешении области видимости
2) TypeError - подразумевает, что разрешение области видимости прошло успешно, то есть было получено значение, но в коде совершена попытка выполнить с 
этим значением недопустимую операцию

?Итоги
Область видимости - набор правил где и как осуществляется поиск индентификатора (переменной). Поиск может выполнятся для цели присваивания ей значения(LHS)
или же для цели чтения ее значения (RHS)

Движок JS сначала компилирует код перед выполнением. При этом команда вида var a = 2; разбивается на 2 части:
1) Сначала var a для обьявления переменной в области видимости. Этот шаг выполняется перед выполнением кода
2) Потом a = 2 для поиска переменной (LHS-ссылка) и присваивания ей значения, если переменная будет успешно найдена


*/



/* 
@ Лексическая область видимости

ОВ - набор правил, управляющих тем как Движок ищет переменную по ее идентификатору и находит ее в текущей области видимости или любой из внешних областей 
видимости в которых она содержится 


Существет 2 основных модели работы области видимости:
1) Лексическая область видимости (lexical scope) - используется в подавляющем большинстве языков программирования
2) Динамическая область видимости - использвуется в некоторых (Bash, Perl)

Первая традиционная фаза работы стандартного компилятора называется лексически анализом (или разбиением на токены). Процесс лексичесеого анализа 
изучает последовательность символов исходного кода и назначает семантический смысл токенам в результате разборас учетом состояния. Именно этот фундамент закладывает
понимание что такое ЛОВ и откуда берется это название.
Лексической областью видимости называется область видимости определяемая на стадии лексического анализа. Другими словами ЛОВ определяется тем, где вы 
разместили переменные и блоки области видимости во время написания программы, и следовательно жестко фиксируется на момент обработки вашего кода лексическим 
анализатором.


Структура и относительное размещение пузырей областей видимости полностью объясняет движку где он должен искать переменную.

Неважно где и как вызывается функция. Ее лексическая область видимости определяется только тем где в исходном коде она была объявлена.

eval(str) - функция,которая получает строку и интерпретирует содержимое строки так,словно это реальный код в текущей точке программы. Иначе говоря мы можем
на программном уровне генерировать код внутри своей программы и выполнять сгенерированный код так словно мы сами его написали
*/


/* 
? ЗАДАЧКИ на что выведет и почему
*/

// @Пример 1
/* function foo(a) {
    console.log( a + b );
 }

var b = 2;
foo( 2 ); // 4 */

// @Пример 2
/* console.log(i)
for (let i=0; i<10; i++) {
    console.log( i );
}
console.log(i) */

// @ Пример 3 - eval без строго режима
/* function foo(str, a) {
    eval( str ); // изменение!
    console.log( a, b );
 }
var b = 2;
foo( "var b = 3;", 1 ); */

// @ Пример 4 - eval в строгом режиме
/* function foo(str) {
    "use strict";
    eval( str );
    console.log( a ); // ReferenceError: переменная a
   }
 foo( "var a = 2" ); */


/* 
@ Функциональные и блочные области видимости

 Область видимости состоит из пузырей. Каждый пузырь представляет собой нечто вроде контейнера, в котором объявляются идентификаторы (переменные и функции).
 Пузыри вложены друг в друга, причем эта вложенность определятся на стадии написания кода. 
 ? Но что именно создает новый пузырь?

 Каждая объявленная функция создает область видимости для себя
*/