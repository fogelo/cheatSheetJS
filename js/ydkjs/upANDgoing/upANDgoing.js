/* 
  Программа - это набор инструкций, сообщающих компьютеру что нужно сделать. 
  {} или 2 - это литеральные значения, поскольку они сами по себе,тоесть не хранятся в переменной.
   Значения, непосредственно включаемые в исходный код, называются литералы
    
   
   ? Чтобы ввести несколько строк в консоли за раз, используйте <shift> + <enter>, чтобы переместиться на новую строку.

   ? Вы должны стремиться писать программы, которые не только правильно работают, но и понятны при их изучении. 

   ? В js типизированные значения, а не типизированные переменные. 
   ? Только у значений есть типы в JavaScript, переменные являются всего лишь контейнерами для этих значений

   Переменная - контейнер, чтобы хранить определенный тип значения. 
   Статическая типизация - контроль типов.
   Динамическая типизация - слабая типизация, позволяет переменной хранить значение любого типа в любой момент времени.

*/

/* //@Взаимодействие c пользователем через propmt
age = prompt( "Please tell me your age:" );
console.log( age ) */

//  break и return

// анонимные и именованные функции
var foo = function () {
    // ..
  };
  var x = function bar() {
    // ..
  };
  
  // Выражения немедленно вызываемых функций (Immediately Invoked Function Expressions (IIFEs))
  // Нужно чтобы объявлять переменные, которые не будут влиять на код, окружающий IIFE снаружи
  (function IIFE() {
    console.log("Hello!");
  })();
  // "Hello!"
  
  
  // §Замыкание - это доступ
  // Замыкание - возможность запомнить и продолжить работу в области видимости функции даже когда функци уже закончила свою работу.
  //@ Пример замыкания 1
  // В данном примере makeAdder заканчивает свою работу, но мы имеем достуа к ее переменной x. Когда мы вызываем makeAdder(1) она нам
  // возвращает ссылку на ее внутреннюю функцию add, которая запоминает x как 1. Мы эту ссылку называли plusOne
  const makeAdder = (x) => {
    const add = (y) => {
      return x + y
    }
    return add
  }
  const plusOne = makeAdder(1)
  console.log(plusOne(10))
  console.log(plusOne(20))
  
  
  //@ Пример замыкания 2
  // В данном примере после того как функция foo1 отработала функция add все еще имеет доступ к переменной x
  const foo1 = () => {
    let x = 0
    const add = (y) => {
      x = x + y
      return x
    }
    return add
  }
  const bar1 = foo1()
  console.log(bar1(5))
  console.log(bar1(5))
  
  //@ Пример замыкания 3 (модульный шаблон)
  // Модули позволяют определять переменные и функции, которые скрыты от внешнего мира и публичное api, которое доступно снаружи
  
  function User() {
    let username, password
    function doLogin(name, pass) {
      username = name
      password = pass
    }
    function showLogin() {
      console.log(username, password)
    }
    const publicApi = {
      login: doLogin,
      showLogin
    }
    return publicApi
  }
  const anton = User()
  /*  
  Функция User закончила свою работы, но мы все еще имеем возможность использовать переменные username, password.
  Мы можем использовать область видимости в которой они объявлены,
  так так сборщик мусора их не удалит поскольку у нас есть ссылка anton на функцию doLogin, которая объявлена в этой области. 
  Есть ссылка на область видимости - значит есть замыкание
   
  При выполнении User() создается экземпляр модуля User и создается целая новая область видимости и также новая копия каждой из этих внутренних переменных 
  и функций. У doLogin есть замыкание на username и password, что значит, что она сохраняет свой доступ к ним даже после того User() завершит свое выполнеие
   */
  anton.login("anton", "123") //задаем значения
  anton.showLogin() //смотрим
  anton.login("ivan", "456") //задаем значения
  anton.showLogin() //смотрим повторно, замыкание работает!
  
  
  // § this - это ссылка.
  /* 
  this в js не связан с объектно-ориентированным шаблонами, в js - это другой механизм.
  this - это ссылка, которая указывает на объект. 
  На какой объект указывает ссылка this зависит от того как была вызвана функция внутри котрой есть эта сслыка
  
  */
  

  //@ Иллюстрация того как ссылкой на какой объект является this в зависимости от того как была вызвана функция.
  function foo3() {
    console.log(this.bar);
  }
  
  var bar = "global";                  // bar установиться в объект window
  let obj1 = {
    bar: "obj1",
    foo3: foo3
  };
  let obj2 = {
    bar: "obj2"
  };


  // разынй вызов функции по разному устанавливает ссылкой на какой объект является this
  foo3();                               // выведет global, так как this - ссылка на window, если bar была бы обявлена let, тогда было бы undefined
  obj1.foo3();                          // выведет obj1
  foo3.call(obj2);                      // выведет obj2, так как мы при помощи call явно указываем, что this внутри foo3 это сслыка на obj2
  new foo3();                           // undefined


  // § Прототипы 

  /*  */